Here is the promp used with curosr AI to create the existing framework.

I'm building a Tamagotchi Leaderboard app in React Native with Expo for my biomedical engineering capstone.

PROJECT OVERVIEW:
- Users can create and care for a virtual Tamagotchi pet
- The app tracks pet stats over time and displays a competitive leaderboard
- Real-time updates when other users interact with their pets

TECH STACK:
- React Native (Expo)
- Supabase (PostgreSQL database + authentication)
- Supabase Real-time subscriptions (live updates)
- React Navigation (routing)
- TypeScript for type safety

DATA MODEL:

Users table (managed by Supabase Auth):
- id (UUID - auto from auth.uid())
- username (string, unique)
- email (string, unique)
- created_at (timestamp)
- updated_at (timestamp)

Tamagotchis table:
- id (UUID, primary key)
- user_id (UUID, foreign key to auth.users)
- name (string)
- health (integer, 0-100)
- hunger (integer, 0-100)
- happiness (integer, 0-100)
- avatar (emoji or string)
- created_at (timestamp)
- last_interaction_time (timestamp)
- total_interactions_this_week (integer)
- is_alive (boolean)

Leaderboard view (or query results):
- Ranks pets by total_interactions_this_week
- Includes pet name, owner username, interactions, avatar
- Scoped to current week

CORE FEATURES:

1. Authentication Screen
- Sign up with email/password using Supabase Auth
- Login with email/password using Supabase Auth
- Error handling for invalid credentials
- Navigation to home after successful authentication
- Session persistence using Supabase Auth state

2. Home Screen
- Display user's Tamagotchi (if exists)
- Show pet name, avatar, and current stats (health, hunger, happiness)
- Stats displayed as progress bars with percentages
- Three action buttons: Feed, Play, Sleep
- Real-time updates when stats change

3. Stat Change Logic
- Feed button: hunger -30, happiness +10, health +5
- Play button: hunger -20, happiness +30, health -5
- Sleep button: hunger -10, health +50, happiness +50
- All stats clamped between 0-100
- Each action increments total_interactions_this_week
- Updates last_interaction_time to current time
- Immediately update Supabase after each action
- Handle optimistic updates for better UX

4. Pet Creation Screen
- If user has no pet, show screen to create one
- Text input for pet name
- Simple avatar picker (use emojis: üê¢ ü¶é üêâ ü¶ú)
- Create button saves to Supabase
- Navigate to home screen after creation

5. Leaderboard Screen
- Display top 10 pets ranked by total_interactions_this_week this week
- Each entry shows: rank, pet name, owner username, total interactions, pet avatar
- Real-time updates using Supabase real-time subscriptions (onSnapshot equivalent)
- Pull-to-refresh functionality
- Empty state message if no pets exist
- Uses Supabase query with order by and limit

6. Settings Screen
- Display current username
- Option to change username (with input, validation, update in users table)
- Option to rename Tamagotchi (update in tamagotchis table)
- Sign out button with confirmation dialog (Supabase signOut)
- Back button to home screen

DESIGN REQUIREMENTS:
- Use modern, clean UI (no skeuomorphism)
- Stats should have visual progress bars (health=red/green gradient, hunger=orange, happiness=yellow)
- Buttons should be large and easy to tap
- Color scheme: use teal/blue as primary, with accent colors for stats
- Responsive layout (works on phones and tablets)
- Dark mode support (if device has dark mode enabled)
- All text should be readable (good contrast)

SUPABASE SETUP:
- Initialize Supabase client with credentials from .env
- Set up Supabase Authentication (email/password provider)
- Create PostgreSQL tables (users, tamagotchis, leaderboard view)
- Set up Row Level Security (RLS) policies:
  - Users can read/write their own user profile
  - Users can create their own tamagotchi
  - Users can read/write their own tamagotchi
  - Users can read all tamagotchis (for leaderboard)
  - Prevent unauthorized writes to other users' data
- Enable real-time subscriptions for tamagotchis table
- Create database function to reset weekly interaction counts (optional: via cron job)

CUSTOM HOOKS:
- useAuth: Handle sign up, login, logout, auth state
- useTamagotchi: Fetch and manage user's pet, real-time updates
- useLeaderboard: Fetch top 10 pets, real-time leaderboard updates
- useTamagotchiActions: Handle feed, play, sleep logic with Supabase updates

ERROR HANDLING:
- Network error handling (show offline message if no internet)
- Invalid input validation (empty username, invalid email)
- Supabase errors (auth failures, write failures) with user-friendly messages
- Graceful degradation (leaderboard still works if one pet fails to load)
- Handle real-time subscription errors

NAVIGATION STRUCTURE:
- Use React Navigation (stack + bottom tabs)
- Tabs: Home, Leaderboard, Settings
- Auth stack for login/signup (conditional based on session)
- Conditional rendering based on auth state

PERFORMANCE:
- Lazy load images/avatars
- Optimize Supabase queries (only fetch top 10 for leaderboard, use select() to limit columns)
- Use memoization for heavy components
- Cache user data locally with AsyncStorage
- Use real-time subscriptions efficiently (unsubscribe on unmount)

NEXT STEPS:
1. Set up Supabase project and get credentials
2. Create database tables and RLS policies
3. Generate complete project structure
4. Create config/supabase.ts with client initialization
5. Create all screens (Auth, Home, Leaderboard, Settings, PetCreation)
6. Create custom hooks (useAuth, useTamagotchi, useLeaderboard, useTamagotchiActions)
7. Set up navigation with React Navigation
8. Add TypeScript types for all data models
9. Include error handling and loading states throughout
10. Test real-time updates with multiple users

Please generate production-ready code with:
- Full TypeScript support
- Proper error handling and user-friendly error messages
- Comments explaining complex logic
- Following React Native best practices
- All files organized in a logical folder structure
- Supabase row-level security policies
- Real-time subscription management

1/26/2026 - New Prompt to fix issues:
COMPREHENSIVE SUPABASE TAMAGOTCHI APP FIX

PROBLEM:
Foreign key constraint error (code 23503) when users sign up:
"Key (id)=(88d0c346-2426-47eb-923d-e8b686316077) is not present in table "users"."

ROOT CAUSE ANALYSIS:
We ran Supabase migrations that created a users table with a foreign key constraint 
linking to auth.users. The problem is that when a new user signs up:

1. Supabase Auth creates a user in auth.users with a UUID
2. Our app code tries to INSERT into public.users table with that UUID
3. But the foreign key constraint is failing because of how the table was initially set up

WHAT WE DID (ORIGINAL MIGRATIONS):
We ran 3 migration files:
1. 001_initial_schema.sql - Created users table with structure:
   - id UUID PRIMARY KEY
   - username TEXT UNIQUE NOT NULL
   - email TEXT UNIQUE NOT NULL
   - created_at TIMESTAMP
   - updated_at TIMESTAMP

2. 002_rls_policies.sql - Added Row Level Security policies on users table

3. 003_weekly_reset_function.sql - Created reset function for interactions

THE ISSUE WITH THE ORIGINAL SETUP:
The users table was created with: id UUID PRIMARY KEY
But it's missing the explicit foreign key constraint to auth.users(id)

When Supabase Auth creates a new user, it generates a UUID in auth.users.
When our app tries to insert into public.users, the foreign key constraint 
between public.users.id and auth.users.id isn't working correctly.

WHAT WE NEED TO DO:

Option 1: RECOMMENDED - Fix the users table schema with proper foreign key

In Supabase SQL Editor, run this COMPLETE MIGRATION:

```sql
-- Step 1: Disable RLS temporarily to allow modifications
ALTER TABLE public.users DISABLE ROW LEVEL SECURITY;

-- Step 2: Drop all existing policies
DROP POLICY IF EXISTS "Users can insert own profile" ON public.users;
DROP POLICY IF EXISTS "Users can read all usernames" ON public.users;
DROP POLICY IF EXISTS "Users can read own profile" ON public.users;
DROP POLICY IF EXISTS "Users can update own profile" ON public.users;
DROP POLICY IF EXISTS "Users can insert their own profile" ON public.users;
DROP POLICY IF EXISTS "Users can read all users" ON public.users;
DROP POLICY IF EXISTS "Users can update their own data" ON public.users;

-- Step 3: Drop the old table completely (backup data first if needed)
DROP TABLE IF EXISTS public.users CASCADE;

-- Step 4: Recreate users table with CORRECT foreign key setup
CREATE TABLE public.users (
  id UUID NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT UNIQUE NOT NULL,
  email TEXT UNIQUE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Step 5: Create indexes for performance
CREATE INDEX idx_users_username ON public.users(username);
CREATE INDEX idx_users_email ON public.users(email);

-- Step 6: Re-enable RLS
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- Step 7: Create CORRECT RLS policies for signup to work

-- Allow anyone to insert their own profile (signup)
CREATE POLICY "Enable insert for signup"
ON public.users
FOR INSERT
WITH CHECK (auth.uid() = id);

-- Allow users to read their own profile
CREATE POLICY "Enable select own profile"
ON public.users
FOR SELECT
USING (auth.uid() = id);

-- Allow anyone to read all usernames (for leaderboard)
CREATE POLICY "Enable select all usernames"
ON public.users
FOR SELECT
USING (true);

-- Allow users to update their own profile
CREATE POLICY "Enable update own profile"
ON public.users
FOR UPDATE
USING (auth.uid() = id);

1/26/2026 - perplexity AI fix the issues after running THESE PROGRAMS IN OREDER:
FIX_FORIEIGN_KEY_ISSUE
004_FIX_USERS_TABLE
005_MAUAL_INSERTION

CLEAN UP CODE:
-- Drop ALL existing policies on users table
DROP POLICY IF EXISTS "Anyone can read usernames" ON public.users;
DROP POLICY IF EXISTS "Allow signup profile creation" ON public.users;
DROP POLICY IF EXISTS "Enable insert for signup" ON public.users;
DROP POLICY IF EXISTS "Enable select own profile" ON public.users;
DROP POLICY IF EXISTS "Enable select all usernames" ON public.users;
DROP POLICY IF EXISTS "Enable update own profile" ON public.users;
DROP POLICY IF EXISTS "signup_insert_policy" ON public.users;
DROP POLICY IF EXISTS "select_own_profile" ON public.users;
DROP POLICY IF EXISTS "update_own_profile" ON public.users;
DROP POLICY IF EXISTS "allow_all_insert" ON public.users;
DROP POLICY IF EXISTS "allow_all_select" ON public.users;
DROP POLICY IF EXISTS "allow_all_update" ON public.users;

-- Disable and re-enable RLS to clear state
ALTER TABLE public.users DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- Create fresh, simple policies
CREATE POLICY "insert_users"
ON public.users
FOR INSERT
WITH CHECK (true);

CREATE POLICY "select_users"
ON public.users
FOR SELECT
USING (true);

CREATE POLICY "update_users"
ON public.users
FOR UPDATE
USING (true);

